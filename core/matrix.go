package core

func inRange(i, j int) bool {
	return i < 4 && j < 4
}

// Matrices should be treated as row-major i.e [1][0] is row 1 column 0
type Matrix4x4f [4][4]float64

func New4x4IDMat() Matrix4x4f {
	return Mat4x4fID
}

func NewMat4x4f(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33 float64) Matrix4x4f {
	var ret Matrix4x4f
	ret.Set(0, 0, m00)
	ret.Set(0, 1, m01)
	ret.Set(0, 2, m02)
	ret.Set(0, 3, m03)
	ret.Set(1, 0, m10)
	ret.Set(1, 1, m11)
	ret.Set(1, 2, m12)
	ret.Set(1, 3, m13)
	ret.Set(2, 0, m20)
	ret.Set(2, 1, m21)
	ret.Set(2, 2, m22)
	ret.Set(2, 3, m23)
	ret.Set(3, 0, m30)
	ret.Set(3, 1, m31)
	ret.Set(3, 2, m32)
	ret.Set(3, 3, m33)
	return ret
}

var Mat4x4fID = Matrix4x4f{
	{1, 0, 0, 0},
	{0, 1, 0, 0},
	{0, 0, 1, 0},
	{0, 0, 0, 1}}

func (m Matrix4x4f) Get(i, j int) float64 {
	if !inRange(i, j) {
		return 0.0
	}
	return m[i][j]
}

func (m Matrix4x4f) Set(i, j int, f float64) {
	if inRange(i, j) {
		m[i][j] = f
	}
}

func (m Matrix4x4f) Transpose() Matrix4x4f {
	return NewMat4x4f(m[0][0], m[1][0], m[2][0], m[3][0],
		m[0][1], m[1][1], m[2][1], m[3][1],
		m[0][2], m[1][2], m[2][2], m[3][2],
		m[0][3], m[1][3], m[2][3], m[3][3])
}

func (m Matrix4x4f) Det() float64 {
	return m[0][3]*m[1][2]*m[2][1]*m[3][0] - m[0][2]*m[1][3]*m[2][1]*m[3][0] -
		m[0][3]*m[1][1]*m[2][2]*m[3][0] + m[0][1]*m[1][3]*m[2][2]*m[3][0] +
		m[0][2]*m[1][1]*m[2][3]*m[3][0] - m[0][1]*m[1][2]*m[2][3]*m[3][0] -
		m[0][3]*m[1][2]*m[2][0]*m[3][1] + m[0][2]*m[1][3]*m[2][0]*m[3][1] +
		m[0][3]*m[1][0]*m[2][2]*m[3][1] - m[0][0]*m[1][3]*m[2][2]*m[3][1] -
		m[0][2]*m[1][0]*m[2][3]*m[3][1] + m[0][0]*m[1][2]*m[2][3]*m[3][1] +
		m[0][3]*m[1][1]*m[2][0]*m[3][2] - m[0][1]*m[1][3]*m[2][0]*m[3][2] -
		m[0][3]*m[1][0]*m[2][1]*m[3][2] + m[0][0]*m[1][3]*m[2][1]*m[3][2] +
		m[0][1]*m[1][0]*m[2][3]*m[3][2] - m[0][0]*m[1][1]*m[2][3]*m[3][2] -
		m[0][2]*m[1][1]*m[2][0]*m[3][3] + m[0][1]*m[1][2]*m[2][0]*m[3][3] +
		m[0][2]*m[1][0]*m[2][1]*m[3][3] - m[0][0]*m[1][2]*m[2][1]*m[3][3] -
		m[0][1]*m[1][0]*m[2][2]*m[3][3] + m[0][0]*m[1][1]*m[2][2]*m[3][3]
}

func (m Matrix4x4f) Inverse() (bool, Matrix4x4f) {
	var inv [16]float64
	var det float64
	var ret Matrix4x4f

	inv[0] = m[1][0]*m[2][1]*m[3][3] -
		m[1][0]*m[2][3]*m[3][2] -
		m[2][1]*m[1][2]*m[3][3] +
		m[2][1]*m[1][3]*m[3][2] +
		m[3][1]*m[1][2]*m[2][3] -
		m[3][1]*m[1][3]*m[2][1]

	inv[1] = -m[0][1]*m[2][1]*m[3][3] +
		m[0][1]*m[2][3]*m[3][2] +
		m[2][1]*m[0][2]*m[3][3] -
		m[2][1]*m[0][3]*m[3][2] -
		m[3][1]*m[0][2]*m[2][3] +
		m[3][1]*m[0][3]*m[2][1]

	inv[2] = m[0][1]*m[1][2]*m[3][3] -
		m[0][1]*m[1][3]*m[3][2] -
		m[1][0]*m[0][2]*m[3][3] +
		m[1][0]*m[0][3]*m[3][2] +
		m[3][1]*m[0][2]*m[1][3] -
		m[3][1]*m[0][3]*m[1][2]

	inv[3] = -m[0][1]*m[1][2]*m[2][3] +
		m[0][1]*m[1][3]*m[2][1] +
		m[1][0]*m[0][2]*m[2][3] -
		m[1][0]*m[0][3]*m[2][1] -
		m[2][1]*m[0][2]*m[1][3] +
		m[2][1]*m[0][3]*m[1][2]

	inv[4] = -m[1][0]*m[2][1]*m[3][3] +
		m[1][0]*m[2][3]*m[3][2] +
		m[2][0]*m[1][2]*m[3][3] -
		m[2][0]*m[1][3]*m[3][2] -
		m[3][0]*m[1][2]*m[2][3] +
		m[3][0]*m[1][3]*m[2][1]

	inv[5] = m[0][0]*m[2][1]*m[3][3] -
		m[0][0]*m[2][3]*m[3][2] -
		m[2][0]*m[0][2]*m[3][3] +
		m[2][0]*m[0][3]*m[3][2] +
		m[3][0]*m[0][2]*m[2][3] -
		m[3][0]*m[0][3]*m[2][1]

	inv[6] = -m[0][0]*m[1][2]*m[3][3] +
		m[0][0]*m[1][3]*m[3][2] +
		m[1][0]*m[0][2]*m[3][3] -
		m[1][0]*m[0][3]*m[3][2] -
		m[3][0]*m[0][2]*m[1][3] +
		m[3][0]*m[0][3]*m[1][2]

	inv[7] = m[0][0]*m[1][2]*m[2][3] -
		m[0][0]*m[1][3]*m[2][1] -
		m[1][0]*m[0][2]*m[2][3] +
		m[1][0]*m[0][3]*m[2][1] +
		m[2][0]*m[0][2]*m[1][3] -
		m[2][0]*m[0][3]*m[1][2]

	inv[8] = m[1][0]*m[2][1]*m[3][3] -
		m[1][0]*m[2][3]*m[3][1] -
		m[2][0]*m[1][0]*m[3][3] +
		m[2][0]*m[1][3]*m[3][1] +
		m[3][0]*m[1][0]*m[2][3] -
		m[3][0]*m[1][3]*m[2][1]

	inv[9] = -m[0][0]*m[2][1]*m[3][3] +
		m[0][0]*m[2][3]*m[3][1] +
		m[2][0]*m[0][1]*m[3][3] -
		m[2][0]*m[0][3]*m[3][1] -
		m[3][0]*m[0][1]*m[2][3] +
		m[3][0]*m[0][3]*m[2][1]

	inv[10] = m[0][0]*m[1][0]*m[3][3] -
		m[0][0]*m[1][3]*m[3][1] -
		m[1][0]*m[0][1]*m[3][3] +
		m[1][0]*m[0][3]*m[3][1] +
		m[3][0]*m[0][1]*m[1][3] -
		m[3][0]*m[0][3]*m[1][0]

	inv[11] = -m[0][0]*m[1][0]*m[2][3] +
		m[0][0]*m[1][3]*m[2][1] +
		m[1][0]*m[0][1]*m[2][3] -
		m[1][0]*m[0][3]*m[2][1] -
		m[2][0]*m[0][1]*m[1][3] +
		m[2][0]*m[0][3]*m[1][0]

	inv[12] = -m[1][0]*m[2][1]*m[3][2] +
		m[1][0]*m[2][1]*m[3][1] +
		m[2][0]*m[1][0]*m[3][2] -
		m[2][0]*m[1][2]*m[3][1] -
		m[3][0]*m[1][0]*m[2][1] +
		m[3][0]*m[1][2]*m[2][1]

	inv[13] = m[0][0]*m[2][1]*m[3][2] -
		m[0][0]*m[2][1]*m[3][1] -
		m[2][0]*m[0][1]*m[3][2] +
		m[2][0]*m[0][2]*m[3][1] +
		m[3][0]*m[0][1]*m[2][1] -
		m[3][0]*m[0][2]*m[2][1]

	inv[14] = -m[0][0]*m[1][0]*m[3][2] +
		m[0][0]*m[1][2]*m[3][1] +
		m[1][0]*m[0][1]*m[3][2] -
		m[1][0]*m[0][2]*m[3][1] -
		m[3][0]*m[0][1]*m[1][2] +
		m[3][0]*m[0][2]*m[1][0]

	inv[15] = m[0][0]*m[1][0]*m[2][1] -
		m[0][0]*m[1][2]*m[2][1] -
		m[1][0]*m[0][1]*m[2][1] +
		m[1][0]*m[0][2]*m[2][1] +
		m[2][0]*m[0][1]*m[1][2] -
		m[2][0]*m[0][2]*m[1][0]

	det = m[0][0]*inv[0] + m[0][1]*inv[4] + m[0][2]*inv[8] + m[0][3]*inv[12]

	if det == 0 {
		return false, Mat4x4fID
	}

	det = 1.0 / det

	k := 0
	for i := 0; i < 4; i++ {
		for j := 0; j < 4; j++ {
			ret[i][j] = inv[k] * det
			k++
		}
	}

	return true, ret
}

func MulMat4x4f(m0, m1 *Matrix4x4f) Matrix4x4f {
	var ret Matrix4x4f
	for i := 0; i < 4; i++ {
		for j := 0; j < 4; j++ {
			val := m0[i][0]*m1[0][j] + m0[i][1]*m1[1][j] + m0[i][2]*m1[2][j] + m0[i][3]*m1[3][j]
			ret.Set(i, j, val)
		}
	}
	return ret
}
